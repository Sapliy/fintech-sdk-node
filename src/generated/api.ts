/* tslint:disable */
/* eslint-disable */
/**
 * proto/payments/payments.proto
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AuthAddTeamMemberRequest {
    'orgId'?: string;
    'userId'?: string;
    'role'?: string;
}
export interface AuthAuditLog {
    'id'?: string;
    'orgId'?: string;
    'userId'?: string;
    'action'?: string;
    'resourceType'?: string;
    'resourceId'?: string;
    'metadata'?: string;
    'ipAddress'?: string;
    'createdAt'?: string;
}
export interface AuthCreateSSOProviderRequest {
    'orgId'?: string;
    'name'?: string;
    'providerType'?: string;
    'issuerUrl'?: string;
    'clientId'?: string;
    'clientSecret'?: string;
}
export interface AuthGetAuditLogsResponse {
    'logs'?: Array<AuthAuditLog>;
    'totalCount'?: number;
}
export interface AuthInitiateSSORequest {
    'email'?: string;
    'redirectUri'?: string;
}
export interface AuthInitiateSSOResponse {
    'authUrl'?: string;
}
export interface AuthListTeamMembersResponse {
    'memberships'?: Array<AuthMembership>;
}
export interface AuthMembership {
    'userId'?: string;
    'orgId'?: string;
    'role'?: string;
    'createdAt'?: string;
}
export interface AuthRemoveTeamMemberResponse {
    'success'?: boolean;
}
export interface AuthSSOProvider {
    'id'?: string;
    'orgId'?: string;
    'name'?: string;
    'providerType'?: string;
    'issuerUrl'?: string;
    'clientId'?: string;
    'active'?: boolean;
}
export interface AuthValidateKeyRequest {
    'keyHash'?: string;
}
export interface AuthValidateKeyResponse {
    'valid'?: boolean;
    'userId'?: string;
    'environment'?: string;
    'scopes'?: string;
    'orgId'?: string;
    'role'?: string;
    'rateLimitQuota'?: number;
}
export interface AuthValidateTokenRequest {
    'accessToken'?: string;
}
export interface AuthValidateTokenResponse {
    'valid'?: boolean;
    'clientId'?: string;
    'userId'?: string;
    'scope'?: string;
    'expiresAt'?: string;
}
export interface BillingCreateSubscriptionRequest {
    'userId'?: string;
    'orgId'?: string;
    'planId'?: string;
}
export interface BillingListSubscriptionsResponse {
    'subscriptions'?: Array<BillingSubscription>;
    'totalCount'?: number;
}
export interface BillingSubscription {
    'id'?: string;
    'userId'?: string;
    'orgId'?: string;
    'planId'?: string;
    'status'?: string;
    'currentPeriodStart'?: string;
    'currentPeriodEnd'?: string;
    'createdAt'?: string;
    'canceledAt'?: string;
}
export interface LedgerGetAccountResponse {
    'accountId'?: string;
    'balance'?: string;
    'currency'?: string;
    'createdAt'?: string;
}
export interface LedgerRecordTransactionRequest {
    'accountId'?: string;
    'amount'?: string;
    'currency'?: string;
    'description'?: string;
    'referenceId'?: string;
}
export interface LedgerRecordTransactionResponse {
    'transactionId'?: string;
    'status'?: string;
}
export interface NotificationsCreateWebhookEndpointRequest {
    'url'?: string;
    'enabledEvents'?: Array<string>;
    'description'?: string;
}
export interface NotificationsDeleteWebhookEndpointResponse {
    'success'?: boolean;
}
export interface NotificationsGetNotificationHistoryResponse {
    'notifications'?: Array<NotificationsNotification>;
}
export interface NotificationsListWebhookEndpointsResponse {
    'endpoints'?: Array<NotificationsWebhookEndpoint>;
}
export interface NotificationsNotification {
    'id'?: string;
    'userId'?: string;
    'recipient'?: string;
    'channel'?: string;
    'title'?: string;
    'content'?: string;
    'status'?: string;
    'createdAt'?: string;
    'sentAt'?: string;
}
export interface NotificationsWebhookEndpoint {
    'id'?: string;
    'url'?: string;
    'enabledEvents'?: Array<string>;
    'secret'?: string;
    'status'?: string;
    'createdAt'?: string;
}
export interface PaymentServiceConfirmPaymentIntentBody {
    'paymentMethodId'?: string;
}
export interface PaymentsCreatePaymentIntentRequest {
    'amount'?: string;
    'currency'?: string;
    'description'?: string;
    'applicationFeeAmount'?: string;
    'onBehalfOf'?: string;
}
export interface PaymentsPaymentIntent {
    'id'?: string;
    'amount'?: string;
    'currency'?: string;
    'status'?: string;
    'description'?: string;
    'userId'?: string;
    'applicationFeeAmount'?: string;
    'onBehalfOf'?: string;
    'createdAt'?: string;
}
export interface ProtobufAny {
    [key: string]: object | any;

    '@type'?: string;
}
export interface RpcStatus {
    'code'?: number;
    'message'?: string;
    'details'?: Array<ProtobufAny>;
}
export interface WalletCreateWalletRequest {
    'userId'?: string;
    'currency'?: string;
}
export interface WalletTopUpRequest {
    'userId'?: string;
    'amount'?: string;
    'currency'?: string;
    'referenceId'?: string;
}
export interface WalletTransactionResponse {
    'transactionId'?: string;
    'status'?: string;
}
export interface WalletTransferRequest {
    'fromUserId'?: string;
    'toUserId'?: string;
    'amount'?: string;
    'currency'?: string;
    'referenceId'?: string;
}
export interface WalletWallet {
    'id'?: string;
    'userId'?: string;
    'balance'?: string;
    'currency'?: string;
}

/**
 * AuthServiceApi - axios parameter creator
 */
export const AuthServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AuthAddTeamMemberRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceAddTeamMember: async (body: AuthAddTeamMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('authServiceAddTeamMember', 'body', body)
            const localVarPath = `/v1/auth/teams/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthCreateSSOProviderRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceCreateSSOProvider: async (body: AuthCreateSSOProviderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('authServiceCreateSSOProvider', 'body', body)
            const localVarPath = `/v1/auth/sso/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [orgId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [action] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceGetAuditLogs: async (orgId?: string, limit?: number, offset?: number, action?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/audit_logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceGetSSOProvider: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authServiceGetSSOProvider', 'id', id)
            const localVarPath = `/v1/auth/sso/providers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthInitiateSSORequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceInitiateSSO: async (body: AuthInitiateSSORequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('authServiceInitiateSSO', 'body', body)
            const localVarPath = `/v1/auth/sso/initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceListTeamMembers: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('authServiceListTeamMembers', 'orgId', orgId)
            const localVarPath = `/v1/auth/teams/{orgId}/members`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [orgId] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceRemoveTeamMember: async (orgId?: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/teams/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthValidateKeyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceValidateKey: async (body: AuthValidateKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('authServiceValidateKey', 'body', body)
            const localVarPath = `/v1/auth/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthValidateTokenRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceValidateToken: async (body: AuthValidateTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('authServiceValidateToken', 'body', body)
            const localVarPath = `/v1/auth/validate_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthServiceApi - functional programming interface
 */
export const AuthServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AuthAddTeamMemberRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceAddTeamMember(body: AuthAddTeamMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceAddTeamMember(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceAddTeamMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthCreateSSOProviderRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceCreateSSOProvider(body: AuthCreateSSOProviderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSSOProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceCreateSSOProvider(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceCreateSSOProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [orgId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [action] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceGetAuditLogs(orgId?: string, limit?: number, offset?: number, action?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthGetAuditLogsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceGetAuditLogs(orgId, limit, offset, action, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceGetAuditLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceGetSSOProvider(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSSOProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceGetSSOProvider(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceGetSSOProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthInitiateSSORequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceInitiateSSO(body: AuthInitiateSSORequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthInitiateSSOResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceInitiateSSO(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceInitiateSSO']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceListTeamMembers(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthListTeamMembersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceListTeamMembers(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceListTeamMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [orgId] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceRemoveTeamMember(orgId?: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRemoveTeamMemberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceRemoveTeamMember(orgId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceRemoveTeamMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthValidateKeyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceValidateKey(body: AuthValidateKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthValidateKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceValidateKey(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceValidateKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthValidateTokenRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceValidateToken(body: AuthValidateTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthValidateTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceValidateToken(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceValidateToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthServiceApi - factory interface
 */
export const AuthServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthAddTeamMemberRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceAddTeamMember(body: AuthAddTeamMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthMembership> {
            return localVarFp.authServiceAddTeamMember(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthCreateSSOProviderRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceCreateSSOProvider(body: AuthCreateSSOProviderRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthSSOProvider> {
            return localVarFp.authServiceCreateSSOProvider(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [orgId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [action] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceGetAuditLogs(orgId?: string, limit?: number, offset?: number, action?: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthGetAuditLogsResponse> {
            return localVarFp.authServiceGetAuditLogs(orgId, limit, offset, action, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceGetSSOProvider(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthSSOProvider> {
            return localVarFp.authServiceGetSSOProvider(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthInitiateSSORequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceInitiateSSO(body: AuthInitiateSSORequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthInitiateSSOResponse> {
            return localVarFp.authServiceInitiateSSO(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceListTeamMembers(orgId: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthListTeamMembersResponse> {
            return localVarFp.authServiceListTeamMembers(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [orgId] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceRemoveTeamMember(orgId?: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthRemoveTeamMemberResponse> {
            return localVarFp.authServiceRemoveTeamMember(orgId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthValidateKeyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceValidateKey(body: AuthValidateKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthValidateKeyResponse> {
            return localVarFp.authServiceValidateKey(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthValidateTokenRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceValidateToken(body: AuthValidateTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthValidateTokenResponse> {
            return localVarFp.authServiceValidateToken(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthServiceApi - interface
 */
export interface AuthServiceApiInterface {
    /**
     * 
     * @param {AuthAddTeamMemberRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authServiceAddTeamMember(body: AuthAddTeamMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthMembership>;

    /**
     * 
     * @param {AuthCreateSSOProviderRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authServiceCreateSSOProvider(body: AuthCreateSSOProviderRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthSSOProvider>;

    /**
     * 
     * @param {string} [orgId] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [action] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authServiceGetAuditLogs(orgId?: string, limit?: number, offset?: number, action?: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthGetAuditLogsResponse>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authServiceGetSSOProvider(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthSSOProvider>;

    /**
     * 
     * @param {AuthInitiateSSORequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authServiceInitiateSSO(body: AuthInitiateSSORequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthInitiateSSOResponse>;

    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authServiceListTeamMembers(orgId: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthListTeamMembersResponse>;

    /**
     * 
     * @param {string} [orgId] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authServiceRemoveTeamMember(orgId?: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthRemoveTeamMemberResponse>;

    /**
     * 
     * @param {AuthValidateKeyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authServiceValidateKey(body: AuthValidateKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthValidateKeyResponse>;

    /**
     * 
     * @param {AuthValidateTokenRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authServiceValidateToken(body: AuthValidateTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthValidateTokenResponse>;

}

/**
 * AuthServiceApi - object-oriented interface
 */
export class AuthServiceApi extends BaseAPI implements AuthServiceApiInterface {
    /**
     * 
     * @param {AuthAddTeamMemberRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceAddTeamMember(body: AuthAddTeamMemberRequest, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceAddTeamMember(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthCreateSSOProviderRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceCreateSSOProvider(body: AuthCreateSSOProviderRequest, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceCreateSSOProvider(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [orgId] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [action] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceGetAuditLogs(orgId?: string, limit?: number, offset?: number, action?: string, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceGetAuditLogs(orgId, limit, offset, action, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceGetSSOProvider(id: string, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceGetSSOProvider(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthInitiateSSORequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceInitiateSSO(body: AuthInitiateSSORequest, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceInitiateSSO(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceListTeamMembers(orgId: string, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceListTeamMembers(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [orgId] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceRemoveTeamMember(orgId?: string, userId?: string, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceRemoveTeamMember(orgId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthValidateKeyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceValidateKey(body: AuthValidateKeyRequest, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceValidateKey(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthValidateTokenRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceValidateToken(body: AuthValidateTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceValidateToken(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingServiceApi - axios parameter creator
 */
export const BillingServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingServiceCancelSubscription: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('billingServiceCancelSubscription', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('billingServiceCancelSubscription', 'body', body)
            const localVarPath = `/v1/billing/subscriptions/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BillingCreateSubscriptionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingServiceCreateSubscription: async (body: BillingCreateSubscriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('billingServiceCreateSubscription', 'body', body)
            const localVarPath = `/v1/billing/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingServiceGetSubscription: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('billingServiceGetSubscription', 'id', id)
            const localVarPath = `/v1/billing/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [orgId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingServiceListSubscriptions: async (userId?: string, orgId?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/billing/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingServiceApi - functional programming interface
 */
export const BillingServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingServiceCancelSubscription(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingServiceCancelSubscription(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingServiceApi.billingServiceCancelSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {BillingCreateSubscriptionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingServiceCreateSubscription(body: BillingCreateSubscriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingServiceCreateSubscription(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingServiceApi.billingServiceCreateSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingServiceGetSubscription(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingServiceGetSubscription(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingServiceApi.billingServiceGetSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [orgId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingServiceListSubscriptions(userId?: string, orgId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingListSubscriptionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingServiceListSubscriptions(userId, orgId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingServiceApi.billingServiceListSubscriptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingServiceApi - factory interface
 */
export const BillingServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingServiceCancelSubscription(id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<BillingSubscription> {
            return localVarFp.billingServiceCancelSubscription(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BillingCreateSubscriptionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingServiceCreateSubscription(body: BillingCreateSubscriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<BillingSubscription> {
            return localVarFp.billingServiceCreateSubscription(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingServiceGetSubscription(id: string, options?: RawAxiosRequestConfig): AxiosPromise<BillingSubscription> {
            return localVarFp.billingServiceGetSubscription(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [orgId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingServiceListSubscriptions(userId?: string, orgId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<BillingListSubscriptionsResponse> {
            return localVarFp.billingServiceListSubscriptions(userId, orgId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingServiceApi - interface
 */
export interface BillingServiceApiInterface {
    /**
     * 
     * @param {string} id 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    billingServiceCancelSubscription(id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<BillingSubscription>;

    /**
     * 
     * @param {BillingCreateSubscriptionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    billingServiceCreateSubscription(body: BillingCreateSubscriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<BillingSubscription>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    billingServiceGetSubscription(id: string, options?: RawAxiosRequestConfig): AxiosPromise<BillingSubscription>;

    /**
     * 
     * @param {string} [userId] 
     * @param {string} [orgId] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    billingServiceListSubscriptions(userId?: string, orgId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<BillingListSubscriptionsResponse>;

}

/**
 * BillingServiceApi - object-oriented interface
 */
export class BillingServiceApi extends BaseAPI implements BillingServiceApiInterface {
    /**
     * 
     * @param {string} id 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billingServiceCancelSubscription(id: string, body: object, options?: RawAxiosRequestConfig) {
        return BillingServiceApiFp(this.configuration).billingServiceCancelSubscription(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BillingCreateSubscriptionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billingServiceCreateSubscription(body: BillingCreateSubscriptionRequest, options?: RawAxiosRequestConfig) {
        return BillingServiceApiFp(this.configuration).billingServiceCreateSubscription(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billingServiceGetSubscription(id: string, options?: RawAxiosRequestConfig) {
        return BillingServiceApiFp(this.configuration).billingServiceGetSubscription(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userId] 
     * @param {string} [orgId] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billingServiceListSubscriptions(userId?: string, orgId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return BillingServiceApiFp(this.configuration).billingServiceListSubscriptions(userId, orgId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LedgerServiceApi - axios parameter creator
 */
export const LedgerServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ledgerServiceGetAccount: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('ledgerServiceGetAccount', 'accountId', accountId)
            const localVarPath = `/v1/ledger/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LedgerRecordTransactionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ledgerServiceRecordTransaction: async (body: LedgerRecordTransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('ledgerServiceRecordTransaction', 'body', body)
            const localVarPath = `/v1/ledger/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LedgerServiceApi - functional programming interface
 */
export const LedgerServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LedgerServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ledgerServiceGetAccount(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LedgerGetAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ledgerServiceGetAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LedgerServiceApi.ledgerServiceGetAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LedgerRecordTransactionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ledgerServiceRecordTransaction(body: LedgerRecordTransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LedgerRecordTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ledgerServiceRecordTransaction(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LedgerServiceApi.ledgerServiceRecordTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LedgerServiceApi - factory interface
 */
export const LedgerServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LedgerServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ledgerServiceGetAccount(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<LedgerGetAccountResponse> {
            return localVarFp.ledgerServiceGetAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LedgerRecordTransactionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ledgerServiceRecordTransaction(body: LedgerRecordTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<LedgerRecordTransactionResponse> {
            return localVarFp.ledgerServiceRecordTransaction(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LedgerServiceApi - interface
 */
export interface LedgerServiceApiInterface {
    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ledgerServiceGetAccount(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<LedgerGetAccountResponse>;

    /**
     * 
     * @param {LedgerRecordTransactionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ledgerServiceRecordTransaction(body: LedgerRecordTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<LedgerRecordTransactionResponse>;

}

/**
 * LedgerServiceApi - object-oriented interface
 */
export class LedgerServiceApi extends BaseAPI implements LedgerServiceApiInterface {
    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ledgerServiceGetAccount(accountId: string, options?: RawAxiosRequestConfig) {
        return LedgerServiceApiFp(this.configuration).ledgerServiceGetAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LedgerRecordTransactionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ledgerServiceRecordTransaction(body: LedgerRecordTransactionRequest, options?: RawAxiosRequestConfig) {
        return LedgerServiceApiFp(this.configuration).ledgerServiceRecordTransaction(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationServiceApi - axios parameter creator
 */
export const NotificationServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NotificationsCreateWebhookEndpointRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationServiceCreateWebhookEndpoint: async (body: NotificationsCreateWebhookEndpointRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('notificationServiceCreateWebhookEndpoint', 'body', body)
            const localVarPath = `/v1/webhooks/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationServiceDeleteWebhookEndpoint: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationServiceDeleteWebhookEndpoint', 'id', id)
            const localVarPath = `/v1/webhooks/endpoints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationServiceGetNotificationHistory: async (userId?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationServiceListWebhookEndpoints: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/webhooks/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationServiceApi - functional programming interface
 */
export const NotificationServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {NotificationsCreateWebhookEndpointRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationServiceCreateWebhookEndpoint(body: NotificationsCreateWebhookEndpointRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsWebhookEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationServiceCreateWebhookEndpoint(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationServiceApi.notificationServiceCreateWebhookEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationServiceDeleteWebhookEndpoint(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsDeleteWebhookEndpointResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationServiceDeleteWebhookEndpoint(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationServiceApi.notificationServiceDeleteWebhookEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationServiceGetNotificationHistory(userId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsGetNotificationHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationServiceGetNotificationHistory(userId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationServiceApi.notificationServiceGetNotificationHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationServiceListWebhookEndpoints(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsListWebhookEndpointsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationServiceListWebhookEndpoints(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationServiceApi.notificationServiceListWebhookEndpoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationServiceApi - factory interface
 */
export const NotificationServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {NotificationsCreateWebhookEndpointRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationServiceCreateWebhookEndpoint(body: NotificationsCreateWebhookEndpointRequest, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsWebhookEndpoint> {
            return localVarFp.notificationServiceCreateWebhookEndpoint(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationServiceDeleteWebhookEndpoint(id: string, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsDeleteWebhookEndpointResponse> {
            return localVarFp.notificationServiceDeleteWebhookEndpoint(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationServiceGetNotificationHistory(userId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsGetNotificationHistoryResponse> {
            return localVarFp.notificationServiceGetNotificationHistory(userId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationServiceListWebhookEndpoints(options?: RawAxiosRequestConfig): AxiosPromise<NotificationsListWebhookEndpointsResponse> {
            return localVarFp.notificationServiceListWebhookEndpoints(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationServiceApi - interface
 */
export interface NotificationServiceApiInterface {
    /**
     * 
     * @param {NotificationsCreateWebhookEndpointRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    notificationServiceCreateWebhookEndpoint(body: NotificationsCreateWebhookEndpointRequest, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsWebhookEndpoint>;

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    notificationServiceDeleteWebhookEndpoint(id: string, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsDeleteWebhookEndpointResponse>;

    /**
     * 
     * @param {string} [userId] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    notificationServiceGetNotificationHistory(userId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsGetNotificationHistoryResponse>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    notificationServiceListWebhookEndpoints(options?: RawAxiosRequestConfig): AxiosPromise<NotificationsListWebhookEndpointsResponse>;

}

/**
 * NotificationServiceApi - object-oriented interface
 */
export class NotificationServiceApi extends BaseAPI implements NotificationServiceApiInterface {
    /**
     * 
     * @param {NotificationsCreateWebhookEndpointRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationServiceCreateWebhookEndpoint(body: NotificationsCreateWebhookEndpointRequest, options?: RawAxiosRequestConfig) {
        return NotificationServiceApiFp(this.configuration).notificationServiceCreateWebhookEndpoint(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationServiceDeleteWebhookEndpoint(id: string, options?: RawAxiosRequestConfig) {
        return NotificationServiceApiFp(this.configuration).notificationServiceDeleteWebhookEndpoint(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userId] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationServiceGetNotificationHistory(userId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return NotificationServiceApiFp(this.configuration).notificationServiceGetNotificationHistory(userId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationServiceListWebhookEndpoints(options?: RawAxiosRequestConfig) {
        return NotificationServiceApiFp(this.configuration).notificationServiceListWebhookEndpoints(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentServiceApi - axios parameter creator
 */
export const PaymentServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {PaymentServiceConfirmPaymentIntentBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentServiceConfirmPaymentIntent: async (id: string, body: PaymentServiceConfirmPaymentIntentBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentServiceConfirmPaymentIntent', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('paymentServiceConfirmPaymentIntent', 'body', body)
            const localVarPath = `/v1/payments/intents/{id}/confirm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PaymentsCreatePaymentIntentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentServiceCreatePaymentIntent: async (body: PaymentsCreatePaymentIntentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('paymentServiceCreatePaymentIntent', 'body', body)
            const localVarPath = `/v1/payments/intents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentServiceRefundPaymentIntent: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentServiceRefundPaymentIntent', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('paymentServiceRefundPaymentIntent', 'body', body)
            const localVarPath = `/v1/payments/intents/{id}/refund`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentServiceApi - functional programming interface
 */
export const PaymentServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {PaymentServiceConfirmPaymentIntentBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentServiceConfirmPaymentIntent(id: string, body: PaymentServiceConfirmPaymentIntentBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsPaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentServiceConfirmPaymentIntent(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentServiceApi.paymentServiceConfirmPaymentIntent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PaymentsCreatePaymentIntentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentServiceCreatePaymentIntent(body: PaymentsCreatePaymentIntentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsPaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentServiceCreatePaymentIntent(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentServiceApi.paymentServiceCreatePaymentIntent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentServiceRefundPaymentIntent(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsPaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentServiceRefundPaymentIntent(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentServiceApi.paymentServiceRefundPaymentIntent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentServiceApi - factory interface
 */
export const PaymentServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {PaymentServiceConfirmPaymentIntentBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentServiceConfirmPaymentIntent(id: string, body: PaymentServiceConfirmPaymentIntentBody, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsPaymentIntent> {
            return localVarFp.paymentServiceConfirmPaymentIntent(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PaymentsCreatePaymentIntentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentServiceCreatePaymentIntent(body: PaymentsCreatePaymentIntentRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsPaymentIntent> {
            return localVarFp.paymentServiceCreatePaymentIntent(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentServiceRefundPaymentIntent(id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsPaymentIntent> {
            return localVarFp.paymentServiceRefundPaymentIntent(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentServiceApi - interface
 */
export interface PaymentServiceApiInterface {
    /**
     * 
     * @param {string} id 
     * @param {PaymentServiceConfirmPaymentIntentBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentServiceConfirmPaymentIntent(id: string, body: PaymentServiceConfirmPaymentIntentBody, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsPaymentIntent>;

    /**
     * 
     * @param {PaymentsCreatePaymentIntentRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentServiceCreatePaymentIntent(body: PaymentsCreatePaymentIntentRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsPaymentIntent>;

    /**
     * 
     * @param {string} id 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paymentServiceRefundPaymentIntent(id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsPaymentIntent>;

}

/**
 * PaymentServiceApi - object-oriented interface
 */
export class PaymentServiceApi extends BaseAPI implements PaymentServiceApiInterface {
    /**
     * 
     * @param {string} id 
     * @param {PaymentServiceConfirmPaymentIntentBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentServiceConfirmPaymentIntent(id: string, body: PaymentServiceConfirmPaymentIntentBody, options?: RawAxiosRequestConfig) {
        return PaymentServiceApiFp(this.configuration).paymentServiceConfirmPaymentIntent(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PaymentsCreatePaymentIntentRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentServiceCreatePaymentIntent(body: PaymentsCreatePaymentIntentRequest, options?: RawAxiosRequestConfig) {
        return PaymentServiceApiFp(this.configuration).paymentServiceCreatePaymentIntent(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentServiceRefundPaymentIntent(id: string, body: object, options?: RawAxiosRequestConfig) {
        return PaymentServiceApiFp(this.configuration).paymentServiceRefundPaymentIntent(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletServiceApi - axios parameter creator
 */
export const WalletServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {WalletCreateWalletRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletServiceCreateWallet: async (body: WalletCreateWalletRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('walletServiceCreateWallet', 'body', body)
            const localVarPath = `/v1/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletServiceGetWallet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('walletServiceGetWallet', 'userId', userId)
            const localVarPath = `/v1/wallets/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WalletTopUpRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletServiceTopUp: async (body: WalletTopUpRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('walletServiceTopUp', 'body', body)
            const localVarPath = `/v1/wallets/top-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WalletTransferRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletServiceTransfer: async (body: WalletTransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('walletServiceTransfer', 'body', body)
            const localVarPath = `/v1/wallets/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletServiceApi - functional programming interface
 */
export const WalletServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {WalletCreateWalletRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletServiceCreateWallet(body: WalletCreateWalletRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletServiceCreateWallet(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletServiceApi.walletServiceCreateWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletServiceGetWallet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletServiceGetWallet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletServiceApi.walletServiceGetWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {WalletTopUpRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletServiceTopUp(body: WalletTopUpRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletServiceTopUp(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletServiceApi.walletServiceTopUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {WalletTransferRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletServiceTransfer(body: WalletTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletServiceTransfer(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletServiceApi.walletServiceTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletServiceApi - factory interface
 */
export const WalletServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {WalletCreateWalletRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletServiceCreateWallet(body: WalletCreateWalletRequest, options?: RawAxiosRequestConfig): AxiosPromise<WalletWallet> {
            return localVarFp.walletServiceCreateWallet(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletServiceGetWallet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<WalletWallet> {
            return localVarFp.walletServiceGetWallet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WalletTopUpRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletServiceTopUp(body: WalletTopUpRequest, options?: RawAxiosRequestConfig): AxiosPromise<WalletTransactionResponse> {
            return localVarFp.walletServiceTopUp(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WalletTransferRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletServiceTransfer(body: WalletTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<WalletTransactionResponse> {
            return localVarFp.walletServiceTransfer(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletServiceApi - interface
 */
export interface WalletServiceApiInterface {
    /**
     * 
     * @param {WalletCreateWalletRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    walletServiceCreateWallet(body: WalletCreateWalletRequest, options?: RawAxiosRequestConfig): AxiosPromise<WalletWallet>;

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    walletServiceGetWallet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<WalletWallet>;

    /**
     * 
     * @param {WalletTopUpRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    walletServiceTopUp(body: WalletTopUpRequest, options?: RawAxiosRequestConfig): AxiosPromise<WalletTransactionResponse>;

    /**
     * 
     * @param {WalletTransferRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    walletServiceTransfer(body: WalletTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<WalletTransactionResponse>;

}

/**
 * WalletServiceApi - object-oriented interface
 */
export class WalletServiceApi extends BaseAPI implements WalletServiceApiInterface {
    /**
     * 
     * @param {WalletCreateWalletRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public walletServiceCreateWallet(body: WalletCreateWalletRequest, options?: RawAxiosRequestConfig) {
        return WalletServiceApiFp(this.configuration).walletServiceCreateWallet(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public walletServiceGetWallet(userId: string, options?: RawAxiosRequestConfig) {
        return WalletServiceApiFp(this.configuration).walletServiceGetWallet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WalletTopUpRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public walletServiceTopUp(body: WalletTopUpRequest, options?: RawAxiosRequestConfig) {
        return WalletServiceApiFp(this.configuration).walletServiceTopUp(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WalletTransferRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public walletServiceTransfer(body: WalletTransferRequest, options?: RawAxiosRequestConfig) {
        return WalletServiceApiFp(this.configuration).walletServiceTransfer(body, options).then((request) => request(this.axios, this.basePath));
    }
}



