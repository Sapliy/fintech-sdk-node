/* tslint:disable */
/* eslint-disable */
/**
 * proto/payments/payments.proto
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: version not set
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface AuthAddTeamMemberRequest {
    'orgId'?: string;
    'userId'?: string;
    'role'?: string;
}
export interface AuthAuditLog {
    'id'?: string;
    'orgId'?: string;
    'userId'?: string;
    'action'?: string;
    'resourceType'?: string;
    'resourceId'?: string;
    'metadata'?: string;
    'ipAddress'?: string;
    'createdAt'?: string;
}
export interface AuthCreateSSOProviderRequest {
    'orgId'?: string;
    'name'?: string;
    'providerType'?: string;
    'issuerUrl'?: string;
    'clientId'?: string;
    'clientSecret'?: string;
}
export interface AuthGetAuditLogsResponse {
    'logs'?: Array<AuthAuditLog>;
    'totalCount'?: number;
}
export interface AuthInitiateSSORequest {
    'email'?: string;
    'redirectUri'?: string;
}
export interface AuthInitiateSSOResponse {
    'authUrl'?: string;
}
export interface AuthListTeamMembersResponse {
    'memberships'?: Array<AuthMembership>;
}
export interface AuthMembership {
    'userId'?: string;
    'orgId'?: string;
    'role'?: string;
    'createdAt'?: string;
}
export interface AuthRemoveTeamMemberResponse {
    'success'?: boolean;
}
export interface AuthSSOProvider {
    'id'?: string;
    'orgId'?: string;
    'name'?: string;
    'providerType'?: string;
    'issuerUrl'?: string;
    'clientId'?: string;
    'active'?: boolean;
}
export interface AuthValidateKeyRequest {
    'keyHash'?: string;
}
export interface AuthValidateKeyResponse {
    'valid'?: boolean;
    'userId'?: string;
    'environment'?: string;
    'scopes'?: string;
    'orgId'?: string;
    'role'?: string;
    'rateLimitQuota'?: number;
    'zoneId'?: string;
    'mode'?: string;
}
export interface AuthValidateTokenRequest {
    'accessToken'?: string;
}
export interface AuthValidateTokenResponse {
    'valid'?: boolean;
    'clientId'?: string;
    'userId'?: string;
    'scope'?: string;
    'expiresAt'?: string;
}
export interface BillingCreateSubscriptionRequest {
    'userId'?: string;
    'orgId'?: string;
    'planId'?: string;
}
export interface BillingListSubscriptionsResponse {
    'subscriptions'?: Array<BillingSubscription>;
    'totalCount'?: number;
}
export interface BillingSubscription {
    'id'?: string;
    'userId'?: string;
    'orgId'?: string;
    'planId'?: string;
    'status'?: string;
    'currentPeriodStart'?: string;
    'currentPeriodEnd'?: string;
    'createdAt'?: string;
    'canceledAt'?: string;
}
export interface FlowBulkUpdateFlowsRequest {
    'flowIds'?: Array<string>;
    'enabled'?: boolean;
}
export interface FlowBulkUpdateFlowsResponse {
    'updatedCount'?: number;
}
export interface FlowCreateFlowRequest {
    'zoneId'?: string;
    'name'?: string;
    'nodesJson'?: string;
    'edgesJson'?: string;
}
export interface FlowExecutionStep {
    'nodeId'?: string;
    'status'?: string;
    'inputJson'?: string;
    'outputJson'?: string;
    'error'?: string;
    'startedAt'?: string;
}
export interface FlowFlow {
    'id'?: string;
    'zoneId'?: string;
    'name'?: string;
    'enabled'?: boolean;
    'nodesJson'?: string;
    'edgesJson'?: string;
    'createdAt'?: string;
    'updatedAt'?: string;
}
export interface FlowFlowExecution {
    'id'?: string;
    'flowId'?: string;
    'status'?: string;
    'currentNodeId'?: string;
    'inputJson'?: string;
    'metadataJson'?: string;
    'steps'?: Array<FlowExecutionStep>;
    'startedAt'?: string;
    'finishedAt'?: string;
}
export interface FlowListFlowsResponse {
    'flows'?: Array<FlowFlow>;
}
export interface FlowResumeExecutionResponse {
    'status'?: string;
}
export interface FlowServiceResumeExecutionBody {
    'overridesJson'?: string;
}
export interface FlowServiceUpdateFlowBody {
    'name'?: string;
    'enabled'?: boolean;
    'nodesJson'?: string;
    'edgesJson'?: string;
}
export interface LedgerBulkRecordRequest {
    'transactions'?: Array<LedgerRecordTransactionRequest>;
}
export interface LedgerBulkRecordResponse {
    'responses'?: Array<LedgerRecordTransactionResponse>;
}
export interface LedgerCreateAccountRequest {
    'name'?: string;
    'type'?: string;
    'currency'?: string;
    'zoneId'?: string;
    'mode'?: string;
}
export interface LedgerCreateAccountResponse {
    'accountId'?: string;
    'status'?: string;
}
export interface LedgerGetAccountResponse {
    'accountId'?: string;
    'balance'?: string;
    'currency'?: string;
    'createdAt'?: string;
}
export interface LedgerRecordTransactionRequest {
    'accountId'?: string;
    'amount'?: string;
    'currency'?: string;
    'description'?: string;
    'referenceId'?: string;
    'zoneId'?: string;
    'mode'?: string;
}
export interface LedgerRecordTransactionResponse {
    'transactionId'?: string;
    'status'?: string;
}
export interface NotificationsCreateWebhookEndpointRequest {
    'url'?: string;
    'enabledEvents'?: Array<string>;
    'description'?: string;
}
export interface NotificationsDeleteWebhookEndpointResponse {
    'success'?: boolean;
}
export interface NotificationsGetNotificationHistoryResponse {
    'notifications'?: Array<NotificationsNotification>;
}
export interface NotificationsListWebhookEndpointsResponse {
    'endpoints'?: Array<NotificationsWebhookEndpoint>;
}
export interface NotificationsNotification {
    'id'?: string;
    'userId'?: string;
    'recipient'?: string;
    'channel'?: string;
    'title'?: string;
    'content'?: string;
    'status'?: string;
    'createdAt'?: string;
    'sentAt'?: string;
}
export interface NotificationsWebhookEndpoint {
    'id'?: string;
    'url'?: string;
    'enabledEvents'?: Array<string>;
    'secret'?: string;
    'status'?: string;
    'createdAt'?: string;
}
export interface PaymentServiceConfirmPaymentIntentBody {
    'paymentMethodId'?: string;
}
export interface PaymentsCreatePaymentIntentRequest {
    'amount'?: string;
    'currency'?: string;
    'description'?: string;
    'applicationFeeAmount'?: string;
    'onBehalfOf'?: string;
}
export interface PaymentsPaymentIntent {
    'id'?: string;
    'amount'?: string;
    'currency'?: string;
    'status'?: string;
    'description'?: string;
    'userId'?: string;
    'applicationFeeAmount'?: string;
    'onBehalfOf'?: string;
    'createdAt'?: string;
}
export interface ProtobufAny {
    [key: string]: object | any;

    '@type'?: string;
}
export interface RpcStatus {
    'code'?: number;
    'message'?: string;
    'details'?: Array<ProtobufAny>;
}
export interface WalletCreateWalletRequest {
    'userId'?: string;
    'currency'?: string;
}
export interface WalletTopUpRequest {
    'userId'?: string;
    'amount'?: string;
    'currency'?: string;
    'referenceId'?: string;
}
export interface WalletTransactionResponse {
    'transactionId'?: string;
    'status'?: string;
}
export interface WalletTransferRequest {
    'fromUserId'?: string;
    'toUserId'?: string;
    'amount'?: string;
    'currency'?: string;
    'referenceId'?: string;
}
export interface WalletWallet {
    'id'?: string;
    'userId'?: string;
    'balance'?: string;
    'currency'?: string;
}
export interface ZoneBulkUpdateMetadataRequest {
    'zoneIds'?: Array<string>;
    'metadata'?: { [key: string]: string; };
}
export interface ZoneBulkUpdateMetadataResponse {
    'updatedCount'?: number;
}
export interface ZoneCreateZoneRequest {
    'orgId'?: string;
    'name'?: string;
    'mode'?: string;
    'templateName'?: string;
    'metadata'?: { [key: string]: string; };
}
export interface ZoneListZonesResponse {
    'zones'?: Array<ZoneZone>;
}
export interface ZoneServiceUpdateZoneBody {
    'name'?: string;
    'status'?: string;
    'metadata'?: { [key: string]: string; };
}
export interface ZoneZone {
    'id'?: string;
    'orgId'?: string;
    'name'?: string;
    'mode'?: string;
    'secretKey'?: string;
    'publishableKey'?: string;
    'status'?: string;
    'templateName'?: string;
    'metadata'?: { [key: string]: string; };
    'createdAt'?: string;
}

/**
 * AuthServiceApi - axios parameter creator
 */
export const AuthServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AuthAddTeamMemberRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceAddTeamMember: async (body: AuthAddTeamMemberRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('authServiceAddTeamMember', 'body', body)
            const localVarPath = `/v1/auth/teams/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthCreateSSOProviderRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceCreateSSOProvider: async (body: AuthCreateSSOProviderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('authServiceCreateSSOProvider', 'body', body)
            const localVarPath = `/v1/auth/sso/providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [orgId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [action] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceGetAuditLogs: async (orgId?: string, limit?: number, offset?: number, action?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/audit_logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceGetSSOProvider: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('authServiceGetSSOProvider', 'id', id)
            const localVarPath = `/v1/auth/sso/providers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthInitiateSSORequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceInitiateSSO: async (body: AuthInitiateSSORequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('authServiceInitiateSSO', 'body', body)
            const localVarPath = `/v1/auth/sso/initiate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceListTeamMembers: async (orgId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orgId' is not null or undefined
            assertParamExists('authServiceListTeamMembers', 'orgId', orgId)
            const localVarPath = `/v1/auth/teams/{orgId}/members`
                .replace(`{${"orgId"}}`, encodeURIComponent(String(orgId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [orgId] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceRemoveTeamMember: async (orgId?: string, userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/auth/teams/members`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthValidateKeyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceValidateKey: async (body: AuthValidateKeyRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('authServiceValidateKey', 'body', body)
            const localVarPath = `/v1/auth/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AuthValidateTokenRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceValidateToken: async (body: AuthValidateTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('authServiceValidateToken', 'body', body)
            const localVarPath = `/v1/auth/validate_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthServiceApi - functional programming interface
 */
export const AuthServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AuthAddTeamMemberRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceAddTeamMember(body: AuthAddTeamMemberRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthMembership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceAddTeamMember(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceAddTeamMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthCreateSSOProviderRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceCreateSSOProvider(body: AuthCreateSSOProviderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSSOProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceCreateSSOProvider(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceCreateSSOProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [orgId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [action] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceGetAuditLogs(orgId?: string, limit?: number, offset?: number, action?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthGetAuditLogsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceGetAuditLogs(orgId, limit, offset, action, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceGetAuditLogs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceGetSSOProvider(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSSOProvider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceGetSSOProvider(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceGetSSOProvider']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthInitiateSSORequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceInitiateSSO(body: AuthInitiateSSORequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthInitiateSSOResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceInitiateSSO(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceInitiateSSO']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceListTeamMembers(orgId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthListTeamMembersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceListTeamMembers(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceListTeamMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [orgId] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceRemoveTeamMember(orgId?: string, userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthRemoveTeamMemberResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceRemoveTeamMember(orgId, userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceRemoveTeamMember']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthValidateKeyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceValidateKey(body: AuthValidateKeyRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthValidateKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceValidateKey(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceValidateKey']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AuthValidateTokenRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authServiceValidateToken(body: AuthValidateTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthValidateTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authServiceValidateToken(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authServiceValidateToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthServiceApi - factory interface
 */
export const AuthServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthAddTeamMemberRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceAddTeamMember(body: AuthAddTeamMemberRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthMembership> {
            return localVarFp.authServiceAddTeamMember(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthCreateSSOProviderRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceCreateSSOProvider(body: AuthCreateSSOProviderRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthSSOProvider> {
            return localVarFp.authServiceCreateSSOProvider(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [orgId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [action] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceGetAuditLogs(orgId?: string, limit?: number, offset?: number, action?: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthGetAuditLogsResponse> {
            return localVarFp.authServiceGetAuditLogs(orgId, limit, offset, action, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceGetSSOProvider(id: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthSSOProvider> {
            return localVarFp.authServiceGetSSOProvider(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthInitiateSSORequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceInitiateSSO(body: AuthInitiateSSORequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthInitiateSSOResponse> {
            return localVarFp.authServiceInitiateSSO(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} orgId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceListTeamMembers(orgId: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthListTeamMembersResponse> {
            return localVarFp.authServiceListTeamMembers(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [orgId] 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceRemoveTeamMember(orgId?: string, userId?: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthRemoveTeamMemberResponse> {
            return localVarFp.authServiceRemoveTeamMember(orgId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthValidateKeyRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceValidateKey(body: AuthValidateKeyRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthValidateKeyResponse> {
            return localVarFp.authServiceValidateKey(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AuthValidateTokenRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authServiceValidateToken(body: AuthValidateTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthValidateTokenResponse> {
            return localVarFp.authServiceValidateToken(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthServiceApi - object-oriented interface
 */
export class AuthServiceApi extends BaseAPI {
    /**
     * 
     * @param {AuthAddTeamMemberRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceAddTeamMember(body: AuthAddTeamMemberRequest, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceAddTeamMember(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthCreateSSOProviderRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceCreateSSOProvider(body: AuthCreateSSOProviderRequest, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceCreateSSOProvider(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [orgId] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [action] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceGetAuditLogs(orgId?: string, limit?: number, offset?: number, action?: string, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceGetAuditLogs(orgId, limit, offset, action, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceGetSSOProvider(id: string, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceGetSSOProvider(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthInitiateSSORequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceInitiateSSO(body: AuthInitiateSSORequest, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceInitiateSSO(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} orgId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceListTeamMembers(orgId: string, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceListTeamMembers(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [orgId] 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceRemoveTeamMember(orgId?: string, userId?: string, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceRemoveTeamMember(orgId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthValidateKeyRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceValidateKey(body: AuthValidateKeyRequest, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceValidateKey(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AuthValidateTokenRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public authServiceValidateToken(body: AuthValidateTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authServiceValidateToken(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BillingServiceApi - axios parameter creator
 */
export const BillingServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingServiceCancelSubscription: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('billingServiceCancelSubscription', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('billingServiceCancelSubscription', 'body', body)
            const localVarPath = `/v1/billing/subscriptions/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BillingCreateSubscriptionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingServiceCreateSubscription: async (body: BillingCreateSubscriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('billingServiceCreateSubscription', 'body', body)
            const localVarPath = `/v1/billing/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingServiceGetSubscription: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('billingServiceGetSubscription', 'id', id)
            const localVarPath = `/v1/billing/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [orgId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingServiceListSubscriptions: async (userId?: string, orgId?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/billing/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingServiceApi - functional programming interface
 */
export const BillingServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingServiceCancelSubscription(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingServiceCancelSubscription(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingServiceApi.billingServiceCancelSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {BillingCreateSubscriptionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingServiceCreateSubscription(body: BillingCreateSubscriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingServiceCreateSubscription(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingServiceApi.billingServiceCreateSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingServiceGetSubscription(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingSubscription>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingServiceGetSubscription(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingServiceApi.billingServiceGetSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [orgId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingServiceListSubscriptions(userId?: string, orgId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingListSubscriptionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingServiceListSubscriptions(userId, orgId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingServiceApi.billingServiceListSubscriptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingServiceApi - factory interface
 */
export const BillingServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingServiceCancelSubscription(id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<BillingSubscription> {
            return localVarFp.billingServiceCancelSubscription(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BillingCreateSubscriptionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingServiceCreateSubscription(body: BillingCreateSubscriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<BillingSubscription> {
            return localVarFp.billingServiceCreateSubscription(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingServiceGetSubscription(id: string, options?: RawAxiosRequestConfig): AxiosPromise<BillingSubscription> {
            return localVarFp.billingServiceGetSubscription(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [orgId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingServiceListSubscriptions(userId?: string, orgId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<BillingListSubscriptionsResponse> {
            return localVarFp.billingServiceListSubscriptions(userId, orgId, limit, offset, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingServiceApi - object-oriented interface
 */
export class BillingServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billingServiceCancelSubscription(id: string, body: object, options?: RawAxiosRequestConfig) {
        return BillingServiceApiFp(this.configuration).billingServiceCancelSubscription(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BillingCreateSubscriptionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billingServiceCreateSubscription(body: BillingCreateSubscriptionRequest, options?: RawAxiosRequestConfig) {
        return BillingServiceApiFp(this.configuration).billingServiceCreateSubscription(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billingServiceGetSubscription(id: string, options?: RawAxiosRequestConfig) {
        return BillingServiceApiFp(this.configuration).billingServiceGetSubscription(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userId] 
     * @param {string} [orgId] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public billingServiceListSubscriptions(userId?: string, orgId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return BillingServiceApiFp(this.configuration).billingServiceListSubscriptions(userId, orgId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FlowServiceApi - axios parameter creator
 */
export const FlowServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FlowBulkUpdateFlowsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flowServiceBulkUpdateFlows: async (body: FlowBulkUpdateFlowsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('flowServiceBulkUpdateFlows', 'body', body)
            const localVarPath = `/v1/flows/bulk-update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FlowCreateFlowRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flowServiceCreateFlow: async (body: FlowCreateFlowRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('flowServiceCreateFlow', 'body', body)
            const localVarPath = `/v1/flows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flowServiceGetExecution: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flowServiceGetExecution', 'id', id)
            const localVarPath = `/v1/flows/executions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flowServiceGetFlow: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flowServiceGetFlow', 'id', id)
            const localVarPath = `/v1/flows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [zoneId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flowServiceListFlows: async (zoneId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/flows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (zoneId !== undefined) {
                localVarQueryParameter['zoneId'] = zoneId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} executionId 
         * @param {FlowServiceResumeExecutionBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flowServiceResumeExecution: async (executionId: string, body: FlowServiceResumeExecutionBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'executionId' is not null or undefined
            assertParamExists('flowServiceResumeExecution', 'executionId', executionId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('flowServiceResumeExecution', 'body', body)
            const localVarPath = `/v1/flows/executions/{executionId}/resume`
                .replace(`{${"executionId"}}`, encodeURIComponent(String(executionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {FlowServiceUpdateFlowBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flowServiceUpdateFlow: async (id: string, body: FlowServiceUpdateFlowBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flowServiceUpdateFlow', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('flowServiceUpdateFlow', 'body', body)
            const localVarPath = `/v1/flows/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlowServiceApi - functional programming interface
 */
export const FlowServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlowServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {FlowBulkUpdateFlowsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flowServiceBulkUpdateFlows(body: FlowBulkUpdateFlowsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowBulkUpdateFlowsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flowServiceBulkUpdateFlows(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowServiceApi.flowServiceBulkUpdateFlows']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FlowCreateFlowRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flowServiceCreateFlow(body: FlowCreateFlowRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowFlow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flowServiceCreateFlow(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowServiceApi.flowServiceCreateFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flowServiceGetExecution(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowFlowExecution>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flowServiceGetExecution(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowServiceApi.flowServiceGetExecution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flowServiceGetFlow(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowFlow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flowServiceGetFlow(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowServiceApi.flowServiceGetFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [zoneId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flowServiceListFlows(zoneId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowListFlowsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flowServiceListFlows(zoneId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowServiceApi.flowServiceListFlows']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} executionId 
         * @param {FlowServiceResumeExecutionBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flowServiceResumeExecution(executionId: string, body: FlowServiceResumeExecutionBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowResumeExecutionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flowServiceResumeExecution(executionId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowServiceApi.flowServiceResumeExecution']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {FlowServiceUpdateFlowBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flowServiceUpdateFlow(id: string, body: FlowServiceUpdateFlowBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowFlow>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flowServiceUpdateFlow(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FlowServiceApi.flowServiceUpdateFlow']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FlowServiceApi - factory interface
 */
export const FlowServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlowServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {FlowBulkUpdateFlowsRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flowServiceBulkUpdateFlows(body: FlowBulkUpdateFlowsRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowBulkUpdateFlowsResponse> {
            return localVarFp.flowServiceBulkUpdateFlows(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FlowCreateFlowRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flowServiceCreateFlow(body: FlowCreateFlowRequest, options?: RawAxiosRequestConfig): AxiosPromise<FlowFlow> {
            return localVarFp.flowServiceCreateFlow(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flowServiceGetExecution(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FlowFlowExecution> {
            return localVarFp.flowServiceGetExecution(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flowServiceGetFlow(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FlowFlow> {
            return localVarFp.flowServiceGetFlow(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [zoneId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flowServiceListFlows(zoneId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FlowListFlowsResponse> {
            return localVarFp.flowServiceListFlows(zoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} executionId 
         * @param {FlowServiceResumeExecutionBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flowServiceResumeExecution(executionId: string, body: FlowServiceResumeExecutionBody, options?: RawAxiosRequestConfig): AxiosPromise<FlowResumeExecutionResponse> {
            return localVarFp.flowServiceResumeExecution(executionId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {FlowServiceUpdateFlowBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flowServiceUpdateFlow(id: string, body: FlowServiceUpdateFlowBody, options?: RawAxiosRequestConfig): AxiosPromise<FlowFlow> {
            return localVarFp.flowServiceUpdateFlow(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlowServiceApi - object-oriented interface
 */
export class FlowServiceApi extends BaseAPI {
    /**
     * 
     * @param {FlowBulkUpdateFlowsRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public flowServiceBulkUpdateFlows(body: FlowBulkUpdateFlowsRequest, options?: RawAxiosRequestConfig) {
        return FlowServiceApiFp(this.configuration).flowServiceBulkUpdateFlows(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FlowCreateFlowRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public flowServiceCreateFlow(body: FlowCreateFlowRequest, options?: RawAxiosRequestConfig) {
        return FlowServiceApiFp(this.configuration).flowServiceCreateFlow(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public flowServiceGetExecution(id: string, options?: RawAxiosRequestConfig) {
        return FlowServiceApiFp(this.configuration).flowServiceGetExecution(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public flowServiceGetFlow(id: string, options?: RawAxiosRequestConfig) {
        return FlowServiceApiFp(this.configuration).flowServiceGetFlow(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [zoneId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public flowServiceListFlows(zoneId?: string, options?: RawAxiosRequestConfig) {
        return FlowServiceApiFp(this.configuration).flowServiceListFlows(zoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} executionId 
     * @param {FlowServiceResumeExecutionBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public flowServiceResumeExecution(executionId: string, body: FlowServiceResumeExecutionBody, options?: RawAxiosRequestConfig) {
        return FlowServiceApiFp(this.configuration).flowServiceResumeExecution(executionId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {FlowServiceUpdateFlowBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public flowServiceUpdateFlow(id: string, body: FlowServiceUpdateFlowBody, options?: RawAxiosRequestConfig) {
        return FlowServiceApiFp(this.configuration).flowServiceUpdateFlow(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LedgerServiceApi - axios parameter creator
 */
export const LedgerServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {LedgerBulkRecordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ledgerServiceBulkRecordTransactions: async (body: LedgerBulkRecordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('ledgerServiceBulkRecordTransactions', 'body', body)
            const localVarPath = `/v1/ledger/bulk-transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LedgerCreateAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ledgerServiceCreateAccount: async (body: LedgerCreateAccountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('ledgerServiceCreateAccount', 'body', body)
            const localVarPath = `/v1/ledger/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ledgerServiceGetAccount: async (accountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('ledgerServiceGetAccount', 'accountId', accountId)
            const localVarPath = `/v1/ledger/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LedgerRecordTransactionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ledgerServiceRecordTransaction: async (body: LedgerRecordTransactionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('ledgerServiceRecordTransaction', 'body', body)
            const localVarPath = `/v1/ledger/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LedgerServiceApi - functional programming interface
 */
export const LedgerServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LedgerServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {LedgerBulkRecordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ledgerServiceBulkRecordTransactions(body: LedgerBulkRecordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LedgerBulkRecordResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ledgerServiceBulkRecordTransactions(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LedgerServiceApi.ledgerServiceBulkRecordTransactions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LedgerCreateAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ledgerServiceCreateAccount(body: LedgerCreateAccountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LedgerCreateAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ledgerServiceCreateAccount(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LedgerServiceApi.ledgerServiceCreateAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ledgerServiceGetAccount(accountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LedgerGetAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ledgerServiceGetAccount(accountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LedgerServiceApi.ledgerServiceGetAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LedgerRecordTransactionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ledgerServiceRecordTransaction(body: LedgerRecordTransactionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LedgerRecordTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ledgerServiceRecordTransaction(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LedgerServiceApi.ledgerServiceRecordTransaction']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LedgerServiceApi - factory interface
 */
export const LedgerServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LedgerServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {LedgerBulkRecordRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ledgerServiceBulkRecordTransactions(body: LedgerBulkRecordRequest, options?: RawAxiosRequestConfig): AxiosPromise<LedgerBulkRecordResponse> {
            return localVarFp.ledgerServiceBulkRecordTransactions(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LedgerCreateAccountRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ledgerServiceCreateAccount(body: LedgerCreateAccountRequest, options?: RawAxiosRequestConfig): AxiosPromise<LedgerCreateAccountResponse> {
            return localVarFp.ledgerServiceCreateAccount(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} accountId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ledgerServiceGetAccount(accountId: string, options?: RawAxiosRequestConfig): AxiosPromise<LedgerGetAccountResponse> {
            return localVarFp.ledgerServiceGetAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LedgerRecordTransactionRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ledgerServiceRecordTransaction(body: LedgerRecordTransactionRequest, options?: RawAxiosRequestConfig): AxiosPromise<LedgerRecordTransactionResponse> {
            return localVarFp.ledgerServiceRecordTransaction(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LedgerServiceApi - object-oriented interface
 */
export class LedgerServiceApi extends BaseAPI {
    /**
     * 
     * @param {LedgerBulkRecordRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ledgerServiceBulkRecordTransactions(body: LedgerBulkRecordRequest, options?: RawAxiosRequestConfig) {
        return LedgerServiceApiFp(this.configuration).ledgerServiceBulkRecordTransactions(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LedgerCreateAccountRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ledgerServiceCreateAccount(body: LedgerCreateAccountRequest, options?: RawAxiosRequestConfig) {
        return LedgerServiceApiFp(this.configuration).ledgerServiceCreateAccount(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} accountId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ledgerServiceGetAccount(accountId: string, options?: RawAxiosRequestConfig) {
        return LedgerServiceApiFp(this.configuration).ledgerServiceGetAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LedgerRecordTransactionRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public ledgerServiceRecordTransaction(body: LedgerRecordTransactionRequest, options?: RawAxiosRequestConfig) {
        return LedgerServiceApiFp(this.configuration).ledgerServiceRecordTransaction(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationServiceApi - axios parameter creator
 */
export const NotificationServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NotificationsCreateWebhookEndpointRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationServiceCreateWebhookEndpoint: async (body: NotificationsCreateWebhookEndpointRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('notificationServiceCreateWebhookEndpoint', 'body', body)
            const localVarPath = `/v1/webhooks/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationServiceDeleteWebhookEndpoint: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('notificationServiceDeleteWebhookEndpoint', 'id', id)
            const localVarPath = `/v1/webhooks/endpoints/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationServiceGetNotificationHistory: async (userId?: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationServiceListWebhookEndpoints: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/webhooks/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationServiceApi - functional programming interface
 */
export const NotificationServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {NotificationsCreateWebhookEndpointRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationServiceCreateWebhookEndpoint(body: NotificationsCreateWebhookEndpointRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsWebhookEndpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationServiceCreateWebhookEndpoint(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationServiceApi.notificationServiceCreateWebhookEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationServiceDeleteWebhookEndpoint(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsDeleteWebhookEndpointResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationServiceDeleteWebhookEndpoint(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationServiceApi.notificationServiceDeleteWebhookEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationServiceGetNotificationHistory(userId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsGetNotificationHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationServiceGetNotificationHistory(userId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationServiceApi.notificationServiceGetNotificationHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async notificationServiceListWebhookEndpoints(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NotificationsListWebhookEndpointsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.notificationServiceListWebhookEndpoints(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationServiceApi.notificationServiceListWebhookEndpoints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationServiceApi - factory interface
 */
export const NotificationServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {NotificationsCreateWebhookEndpointRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationServiceCreateWebhookEndpoint(body: NotificationsCreateWebhookEndpointRequest, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsWebhookEndpoint> {
            return localVarFp.notificationServiceCreateWebhookEndpoint(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationServiceDeleteWebhookEndpoint(id: string, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsDeleteWebhookEndpointResponse> {
            return localVarFp.notificationServiceDeleteWebhookEndpoint(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationServiceGetNotificationHistory(userId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): AxiosPromise<NotificationsGetNotificationHistoryResponse> {
            return localVarFp.notificationServiceGetNotificationHistory(userId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notificationServiceListWebhookEndpoints(options?: RawAxiosRequestConfig): AxiosPromise<NotificationsListWebhookEndpointsResponse> {
            return localVarFp.notificationServiceListWebhookEndpoints(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationServiceApi - object-oriented interface
 */
export class NotificationServiceApi extends BaseAPI {
    /**
     * 
     * @param {NotificationsCreateWebhookEndpointRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationServiceCreateWebhookEndpoint(body: NotificationsCreateWebhookEndpointRequest, options?: RawAxiosRequestConfig) {
        return NotificationServiceApiFp(this.configuration).notificationServiceCreateWebhookEndpoint(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationServiceDeleteWebhookEndpoint(id: string, options?: RawAxiosRequestConfig) {
        return NotificationServiceApiFp(this.configuration).notificationServiceDeleteWebhookEndpoint(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userId] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationServiceGetNotificationHistory(userId?: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return NotificationServiceApiFp(this.configuration).notificationServiceGetNotificationHistory(userId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public notificationServiceListWebhookEndpoints(options?: RawAxiosRequestConfig) {
        return NotificationServiceApiFp(this.configuration).notificationServiceListWebhookEndpoints(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentServiceApi - axios parameter creator
 */
export const PaymentServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {PaymentServiceConfirmPaymentIntentBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentServiceConfirmPaymentIntent: async (id: string, body: PaymentServiceConfirmPaymentIntentBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentServiceConfirmPaymentIntent', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('paymentServiceConfirmPaymentIntent', 'body', body)
            const localVarPath = `/v1/payments/intents/{id}/confirm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PaymentsCreatePaymentIntentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentServiceCreatePaymentIntent: async (body: PaymentsCreatePaymentIntentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('paymentServiceCreatePaymentIntent', 'body', body)
            const localVarPath = `/v1/payments/intents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentServiceRefundPaymentIntent: async (id: string, body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentServiceRefundPaymentIntent', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('paymentServiceRefundPaymentIntent', 'body', body)
            const localVarPath = `/v1/payments/intents/{id}/refund`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentServiceApi - functional programming interface
 */
export const PaymentServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {PaymentServiceConfirmPaymentIntentBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentServiceConfirmPaymentIntent(id: string, body: PaymentServiceConfirmPaymentIntentBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsPaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentServiceConfirmPaymentIntent(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentServiceApi.paymentServiceConfirmPaymentIntent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {PaymentsCreatePaymentIntentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentServiceCreatePaymentIntent(body: PaymentsCreatePaymentIntentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsPaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentServiceCreatePaymentIntent(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentServiceApi.paymentServiceCreatePaymentIntent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentServiceRefundPaymentIntent(id: string, body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentsPaymentIntent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentServiceRefundPaymentIntent(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentServiceApi.paymentServiceRefundPaymentIntent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentServiceApi - factory interface
 */
export const PaymentServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {PaymentServiceConfirmPaymentIntentBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentServiceConfirmPaymentIntent(id: string, body: PaymentServiceConfirmPaymentIntentBody, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsPaymentIntent> {
            return localVarFp.paymentServiceConfirmPaymentIntent(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PaymentsCreatePaymentIntentRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentServiceCreatePaymentIntent(body: PaymentsCreatePaymentIntentRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsPaymentIntent> {
            return localVarFp.paymentServiceCreatePaymentIntent(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentServiceRefundPaymentIntent(id: string, body: object, options?: RawAxiosRequestConfig): AxiosPromise<PaymentsPaymentIntent> {
            return localVarFp.paymentServiceRefundPaymentIntent(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentServiceApi - object-oriented interface
 */
export class PaymentServiceApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {PaymentServiceConfirmPaymentIntentBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentServiceConfirmPaymentIntent(id: string, body: PaymentServiceConfirmPaymentIntentBody, options?: RawAxiosRequestConfig) {
        return PaymentServiceApiFp(this.configuration).paymentServiceConfirmPaymentIntent(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PaymentsCreatePaymentIntentRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentServiceCreatePaymentIntent(body: PaymentsCreatePaymentIntentRequest, options?: RawAxiosRequestConfig) {
        return PaymentServiceApiFp(this.configuration).paymentServiceCreatePaymentIntent(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public paymentServiceRefundPaymentIntent(id: string, body: object, options?: RawAxiosRequestConfig) {
        return PaymentServiceApiFp(this.configuration).paymentServiceRefundPaymentIntent(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WalletServiceApi - axios parameter creator
 */
export const WalletServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {WalletCreateWalletRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletServiceCreateWallet: async (body: WalletCreateWalletRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('walletServiceCreateWallet', 'body', body)
            const localVarPath = `/v1/wallets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletServiceGetWallet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('walletServiceGetWallet', 'userId', userId)
            const localVarPath = `/v1/wallets/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WalletTopUpRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletServiceTopUp: async (body: WalletTopUpRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('walletServiceTopUp', 'body', body)
            const localVarPath = `/v1/wallets/top-up`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WalletTransferRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletServiceTransfer: async (body: WalletTransferRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('walletServiceTransfer', 'body', body)
            const localVarPath = `/v1/wallets/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WalletServiceApi - functional programming interface
 */
export const WalletServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WalletServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {WalletCreateWalletRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletServiceCreateWallet(body: WalletCreateWalletRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletServiceCreateWallet(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletServiceApi.walletServiceCreateWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletServiceGetWallet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletWallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletServiceGetWallet(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletServiceApi.walletServiceGetWallet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {WalletTopUpRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletServiceTopUp(body: WalletTopUpRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletServiceTopUp(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletServiceApi.walletServiceTopUp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {WalletTransferRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async walletServiceTransfer(body: WalletTransferRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WalletTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.walletServiceTransfer(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WalletServiceApi.walletServiceTransfer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WalletServiceApi - factory interface
 */
export const WalletServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WalletServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {WalletCreateWalletRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletServiceCreateWallet(body: WalletCreateWalletRequest, options?: RawAxiosRequestConfig): AxiosPromise<WalletWallet> {
            return localVarFp.walletServiceCreateWallet(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletServiceGetWallet(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<WalletWallet> {
            return localVarFp.walletServiceGetWallet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WalletTopUpRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletServiceTopUp(body: WalletTopUpRequest, options?: RawAxiosRequestConfig): AxiosPromise<WalletTransactionResponse> {
            return localVarFp.walletServiceTopUp(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WalletTransferRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        walletServiceTransfer(body: WalletTransferRequest, options?: RawAxiosRequestConfig): AxiosPromise<WalletTransactionResponse> {
            return localVarFp.walletServiceTransfer(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WalletServiceApi - object-oriented interface
 */
export class WalletServiceApi extends BaseAPI {
    /**
     * 
     * @param {WalletCreateWalletRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public walletServiceCreateWallet(body: WalletCreateWalletRequest, options?: RawAxiosRequestConfig) {
        return WalletServiceApiFp(this.configuration).walletServiceCreateWallet(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public walletServiceGetWallet(userId: string, options?: RawAxiosRequestConfig) {
        return WalletServiceApiFp(this.configuration).walletServiceGetWallet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WalletTopUpRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public walletServiceTopUp(body: WalletTopUpRequest, options?: RawAxiosRequestConfig) {
        return WalletServiceApiFp(this.configuration).walletServiceTopUp(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WalletTransferRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public walletServiceTransfer(body: WalletTransferRequest, options?: RawAxiosRequestConfig) {
        return WalletServiceApiFp(this.configuration).walletServiceTransfer(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ZoneServiceApi - axios parameter creator
 */
export const ZoneServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ZoneBulkUpdateMetadataRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneServiceBulkUpdateMetadata: async (body: ZoneBulkUpdateMetadataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('zoneServiceBulkUpdateMetadata', 'body', body)
            const localVarPath = `/v1/zones/bulk-metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ZoneCreateZoneRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneServiceCreateZone: async (body: ZoneCreateZoneRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('zoneServiceCreateZone', 'body', body)
            const localVarPath = `/v1/zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneServiceGetZone: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('zoneServiceGetZone', 'id', id)
            const localVarPath = `/v1/zones/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [orgId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneServiceListZones: async (orgId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (orgId !== undefined) {
                localVarQueryParameter['orgId'] = orgId;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ZoneServiceUpdateZoneBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneServiceUpdateZone: async (id: string, body: ZoneServiceUpdateZoneBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('zoneServiceUpdateZone', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('zoneServiceUpdateZone', 'body', body)
            const localVarPath = `/v1/zones/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ZoneServiceApi - functional programming interface
 */
export const ZoneServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ZoneServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ZoneBulkUpdateMetadataRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneServiceBulkUpdateMetadata(body: ZoneBulkUpdateMetadataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZoneBulkUpdateMetadataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneServiceBulkUpdateMetadata(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZoneServiceApi.zoneServiceBulkUpdateMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {ZoneCreateZoneRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneServiceCreateZone(body: ZoneCreateZoneRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZoneZone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneServiceCreateZone(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZoneServiceApi.zoneServiceCreateZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneServiceGetZone(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZoneZone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneServiceGetZone(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZoneServiceApi.zoneServiceGetZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} [orgId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneServiceListZones(orgId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZoneListZonesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneServiceListZones(orgId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZoneServiceApi.zoneServiceListZones']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {ZoneServiceUpdateZoneBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async zoneServiceUpdateZone(id: string, body: ZoneServiceUpdateZoneBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZoneZone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.zoneServiceUpdateZone(id, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ZoneServiceApi.zoneServiceUpdateZone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ZoneServiceApi - factory interface
 */
export const ZoneServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ZoneServiceApiFp(configuration)
    return {
        /**
         * 
         * @param {ZoneBulkUpdateMetadataRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneServiceBulkUpdateMetadata(body: ZoneBulkUpdateMetadataRequest, options?: RawAxiosRequestConfig): AxiosPromise<ZoneBulkUpdateMetadataResponse> {
            return localVarFp.zoneServiceBulkUpdateMetadata(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ZoneCreateZoneRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneServiceCreateZone(body: ZoneCreateZoneRequest, options?: RawAxiosRequestConfig): AxiosPromise<ZoneZone> {
            return localVarFp.zoneServiceCreateZone(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneServiceGetZone(id: string, options?: RawAxiosRequestConfig): AxiosPromise<ZoneZone> {
            return localVarFp.zoneServiceGetZone(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [orgId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneServiceListZones(orgId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ZoneListZonesResponse> {
            return localVarFp.zoneServiceListZones(orgId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ZoneServiceUpdateZoneBody} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        zoneServiceUpdateZone(id: string, body: ZoneServiceUpdateZoneBody, options?: RawAxiosRequestConfig): AxiosPromise<ZoneZone> {
            return localVarFp.zoneServiceUpdateZone(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ZoneServiceApi - object-oriented interface
 */
export class ZoneServiceApi extends BaseAPI {
    /**
     * 
     * @param {ZoneBulkUpdateMetadataRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public zoneServiceBulkUpdateMetadata(body: ZoneBulkUpdateMetadataRequest, options?: RawAxiosRequestConfig) {
        return ZoneServiceApiFp(this.configuration).zoneServiceBulkUpdateMetadata(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ZoneCreateZoneRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public zoneServiceCreateZone(body: ZoneCreateZoneRequest, options?: RawAxiosRequestConfig) {
        return ZoneServiceApiFp(this.configuration).zoneServiceCreateZone(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public zoneServiceGetZone(id: string, options?: RawAxiosRequestConfig) {
        return ZoneServiceApiFp(this.configuration).zoneServiceGetZone(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [orgId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public zoneServiceListZones(orgId?: string, options?: RawAxiosRequestConfig) {
        return ZoneServiceApiFp(this.configuration).zoneServiceListZones(orgId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {ZoneServiceUpdateZoneBody} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public zoneServiceUpdateZone(id: string, body: ZoneServiceUpdateZoneBody, options?: RawAxiosRequestConfig) {
        return ZoneServiceApiFp(this.configuration).zoneServiceUpdateZone(id, body, options).then((request) => request(this.axios, this.basePath));
    }
}



